/*
PSEUDO CODICE:

SetVentoleMinimo()
camminoStudentiPrecedente = {}
camminoImpostorePrecedente = {}
camminoStudenti = {}
camminoImpostore = {}
ImpostoreNonVince = chiVince(&camminoStudenti, &camminoImpostore)
camminiCambiati = cambiatoCammino(&camminoStudenti, &camminoStudentiPrecedente) || cambiatoCammino(&camminoImpostore, &camminoImpostorePrecedente)
while (ImpostoreNonVince && camminiCambiati):
    impostaVentoleStudenteMax()             //imposta le ventole del cammino dello studente al massimo (ventole€)
    camminoStudentiPrecedente = camminoStudenti
    camminoImpostorePrecedente = camminoImpostore
    camminoStudenti = {}
    camminoImpostore = {}
    ImpostoreNonVince
 = chiVince(&camminoStudenti, &camminoImpostore)
    camminiCambiati = cambiatoCammino(&camminoStudenti, &camminoStudentiPrecedente) || cambiatoCammino(&camminoImpostore, &camminoImpostorePrecedente)
corridoio = getPrimoCorridoioConVentolaInComune()
while (ImpostoreNonVince && corridoio != NULL):
    //sono sicuro che se hanno un nodo in comune il cammino successivo sarà lo stesso e che, siccome l'impostore sta perdendo o pareggiando,
    //lo studente sarà o in vantaggio o a pari distanza
    nodoInComune = corridoio.partenza
    //lo studente è in vantaggio, alzo la ventola al massimo, rendendo il percorso sconveniente anche per l'impostore, ma 
    //spero che l'impostore abbia un percorso alternativo più conveniente
    if (nodoInComune.distanzaStudente < nodoInComune.distanzaImpostore):
        corridoio.impostaVentolaMax()    
    //sono a pari distanza
    else:
        //TODO!!
        //se alzo al massimo la ventola potrei perdere, nel caso in cui lo studente trovi un percorso alternativo più conveniente, perciò keep calm
        //se lascio la ventola al minimo potrei non ottenere una potenziale vittoria
        //qindi dovrei fare Dijkstra senza considerare quel corridoio per vedere quali sono le alternative
*/